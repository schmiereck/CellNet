<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/de/schmiereck/cellNet/CellNetMain.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/schmiereck/cellNet/CellNetMain.java" />
              <option name="originalContent" value="package de.schmiereck.cellNet;&#10;&#10;import java.util.*;&#10;&#10;public class CellNetMain {&#10;    public static boolean showExtraResults = false;&#10;&#10;    public static void main(String[] args) {&#10;        System.out.printf(&quot;CellNet V1.0.0%n&quot;);&#10;        findBooleanRuleNumbers(4, 4);&#10;&#10;        //final Grid grid = GridService.createGrid(3, 4, 0);&#10;        //&#10;        //final int[] inputArr = { 0, 0 };&#10;        //GridService.submitInput(grid, inputArr);&#10;        //CellNetService.calcGrid(grid);&#10;        //final int[] outputArr = GridService.retieveOutput(grid);&#10;    }&#10;&#10;    record OpOutput(String opName, int[][] expectedOutputArrArr) {}&#10;&#10;    private static Integer findBooleanRuleNumbers(final int sizeX, final int sizeY) {&#10;        // Definition der booleschen Operationen und deren erwartete Outputs&#10;        final List&lt;OpOutput&gt; opOutputArr = new ArrayList&lt;&gt;();&#10;        // Reihenfolge: 00, 01, 10, 11&#10;        opOutputArr.add(new OpOutput(&quot;AND&quot;,  new int[][] { { 0 }, { 0 }, { 0 }, { 1 } }));&#10;        opOutputArr.add(new OpOutput(&quot;OR&quot;,   new int[][] { { 0 }, { 1 }, { 1 }, { 1 } }));&#10;        opOutputArr.add(new OpOutput(&quot;NAND&quot;, new int[][] { { 1 }, { 1 }, { 1 }, { 0 } }));&#10;        opOutputArr.add(new OpOutput(&quot;NOR&quot;,  new int[][] { { 1 }, { 0 }, { 0 }, { 0 } }));&#10;        opOutputArr.add(new OpOutput(&quot;XOR&quot;,  new int[][] { { 0 }, { 1 }, { 1 }, { 0 } }));&#10;        opOutputArr.add(new OpOutput(&quot;XNOR&quot;, new int[][] { { 1 }, { 0 }, { 0 }, { 1 } }));&#10;&#10;        // Eingabekombinationen&#10;        final int[][] inputArrArr = { { 0, 0 }, { 0, 1 }, { 1, 0 }, { 1, 1 } };&#10;&#10;        System.out.printf(&quot;---------------------------------------------------------%n&quot;);&#10;        System.out.printf(&quot;size: %d, %d%n&quot;, sizeX, sizeY);&#10;&#10;        final List&lt;Integer&gt;[] matchingRuleListArr = new ArrayList[opOutputArr.size()];&#10;&#10;        for (int pos = 0; pos &lt; opOutputArr.size(); pos++) {&#10;            final OpOutput opOutput = opOutputArr.get(pos);&#10;&#10;            final String opName = opOutput.opName();&#10;            final int[][] expectedOutputArrArr = opOutput.expectedOutputArrArr();&#10;            matchingRuleListArr[pos] = new ArrayList&lt;&gt;();&#10;&#10;            for (int ruleNr = 0; ruleNr &lt;= 255; ruleNr++) {&#10;                boolean allInputsMatch = true;&#10;                inputArrArrPosLoop:&#10;                for (int inputArrArrPos = 0; inputArrArrPos &lt; inputArrArr.length; inputArrArrPos++) {&#10;                    final int[] inputArr = inputArrArr[inputArrArrPos];&#10;&#10;                    final Grid grid = GridService.createGrid(sizeX, sizeY, ruleNr);&#10;&#10;                    GridService.submitInput(grid, inputArr);&#10;                    CellNetService.calcGrid(grid);&#10;                    final int[] outputArr = GridService.retieveOutput(grid);&#10;&#10;                    final int[] expectedOutputArr = expectedOutputArrArr[inputArrArrPos];&#10;                    for (int outputArrPos = 0; outputArrPos &lt; expectedOutputArr.length; outputArrPos++) {&#10;                        if (outputArr[outputArrPos] != expectedOutputArr[outputArrPos]) {&#10;                            allInputsMatch = false;&#10;                            break inputArrArrPosLoop;&#10;                        }&#10;                    }&#10;                }&#10;                if (allInputsMatch) {&#10;                    matchingRuleListArr[pos].add(ruleNr);&#10;                }&#10;            }&#10;            System.out.printf(&quot;%s: %s\n&quot;, opName, matchingRuleListArr[pos]);&#10;        }&#10;&#10;        if (showExtraResults) {&#10;            System.out.printf(&quot;---------------------------------------------------------%n&quot;);&#10;            for (int pos = 0; pos &lt; opOutputArr.size(); pos++) {&#10;                final OpOutput opOutput = opOutputArr.get(pos);&#10;&#10;                final String opName = opOutput.opName();&#10;                final int[][] expectedOutputArrArr = opOutput.expectedOutputArrArr();&#10;&#10;                System.out.printf(&quot;%s: %s\n&quot;, opName, matchingRuleListArr[pos]);&#10;                if (matchingRuleListArr[pos].size() &gt; 0) {&#10;                    printGridForOperation(opName, matchingRuleListArr[pos].getFirst(), inputArrArr, expectedOutputArrArr, sizeX, sizeY);&#10;                }&#10;            }&#10;        }&#10;        Integer universalRuleNr = null;&#10;        for (int pos = 0; pos &lt; matchingRuleListArr.length; pos++) {&#10;            final List&lt;Integer&gt; matchingRuleList = matchingRuleListArr[pos];&#10;&#10;        }&#10;        return universalRuleNr;&#10;    }&#10;&#10;    private static void printGridForOperation(String opName, int ruleNr, int[][] inputArrArr, int[][] expectedOutputArrArr, int sizeX, int sizeY) {&#10;        System.out.printf(&quot;Operation: %s, Regel: %d\n&quot;, opName, ruleNr);&#10;        for (int inputArrArrPos = 0; inputArrArrPos &lt; inputArrArr.length; inputArrArrPos++) {&#10;            final int[] inputArr = inputArrArr[inputArrArrPos];&#10;            final int[] expectedOutputArr = expectedOutputArrArr[inputArrArrPos];&#10;            final Grid grid = GridService.createGrid(sizeX, sizeY, ruleNr);&#10;            GridService.submitInput(grid, inputArr);&#10;            CellNetService.calcGrid(grid);&#10;            final int[] outputArr = GridService.retieveOutput(grid);&#10;            System.out.printf(&quot;Eingabe: %s, Erwartete Ausgabe: %s, TatsÃ¤chliche Ausgabe: %s\n&quot;, Arrays.toString(inputArr), Arrays.toString(expectedOutputArr), Arrays.toString(outputArr));&#10;            printGrid(grid);&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    private static void printGrid(Grid grid) {&#10;        for (int y = 0; y &lt; grid.sizeY; y++) {&#10;            for (int x = 0; x &lt; grid.sizeX; x++) {&#10;                System.out.print(grid.cellArr[y][x].value + &quot; &quot;);&#10;            }&#10;            System.out.println();&#10;        }&#10;        System.out.println();&#10;    }&#10;}" />
              <option name="updatedContent" value="package de.schmiereck.cellNet;&#10;&#10;import java.util.*;&#10;&#10;public class CellNetMain {&#10;    public static boolean showExtraResults = false;&#10;&#10;    public static void main(String[] args) {&#10;        System.out.printf(&quot;CellNet V1.0.0%n&quot;);&#10;        findBooleanRuleNumbers(4, 4);&#10;&#10;        //final Grid grid = GridService.createGrid(3, 4, 0);&#10;        //&#10;        //final int[] inputArr = { 0, 0 };&#10;        //GridService.submitInput(grid, inputArr);&#10;        //CellNetService.calcGrid(grid);&#10;        //final int[] outputArr = GridService.retieveOutput(grid);&#10;    }&#10;&#10;    record OpOutput(String opName, int[][] expectedOutputArrArr) {}&#10;&#10;    private static Integer findBooleanRuleNumbers(final int sizeX, final int sizeY) {&#10;        // Definition der booleschen Operationen und deren erwartete Outputs&#10;        final List&lt;OpOutput&gt; opOutputArr = new ArrayList&lt;&gt;();&#10;        // Reihenfolge: 00, 01, 10, 11&#10;        opOutputArr.add(new OpOutput(&quot;AND&quot;,  new int[][] { { 0 }, { 0 }, { 0 }, { 1 } }));&#10;        opOutputArr.add(new OpOutput(&quot;OR&quot;,   new int[][] { { 0 }, { 1 }, { 1 }, { 1 } }));&#10;        opOutputArr.add(new OpOutput(&quot;NAND&quot;, new int[][] { { 1 }, { 1 }, { 1 }, { 0 } }));&#10;        opOutputArr.add(new OpOutput(&quot;NOR&quot;,  new int[][] { { 1 }, { 0 }, { 0 }, { 0 } }));&#10;        opOutputArr.add(new OpOutput(&quot;XOR&quot;,  new int[][] { { 0 }, { 1 }, { 1 }, { 0 } }));&#10;        opOutputArr.add(new OpOutput(&quot;XNOR&quot;, new int[][] { { 1 }, { 0 }, { 0 }, { 1 } }));&#10;&#10;        // Eingabekombinationen&#10;        final int[][] inputArrArr = { { 0, 0 }, { 0, 1 }, { 1, 0 }, { 1, 1 } };&#10;&#10;        System.out.printf(&quot;---------------------------------------------------------%n&quot;);&#10;        System.out.printf(&quot;size: %d, %d%n&quot;, sizeX, sizeY);&#10;&#10;        final List&lt;Integer&gt;[] matchingRuleListArr = new ArrayList[opOutputArr.size()];&#10;&#10;        for (int pos = 0; pos &lt; opOutputArr.size(); pos++) {&#10;            final OpOutput opOutput = opOutputArr.get(pos);&#10;&#10;            final String opName = opOutput.opName();&#10;            final int[][] expectedOutputArrArr = opOutput.expectedOutputArrArr();&#10;            matchingRuleListArr[pos] = new ArrayList&lt;&gt;();&#10;&#10;            for (int ruleNr = 0; ruleNr &lt;= 255; ruleNr++) {&#10;                boolean allInputsMatch = true;&#10;                inputArrArrPosLoop:&#10;                for (int inputArrArrPos = 0; inputArrArrPos &lt; inputArrArr.length; inputArrArrPos++) {&#10;                    final int[] inputArr = inputArrArr[inputArrArrPos];&#10;&#10;                    final Grid grid = GridService.createGrid(sizeX, sizeY, ruleNr);&#10;&#10;                    GridService.submitInput(grid, inputArr);&#10;                    CellNetService.calcGrid(grid);&#10;                    final int[] outputArr = GridService.retieveOutput(grid);&#10;&#10;                    final int[] expectedOutputArr = expectedOutputArrArr[inputArrArrPos];&#10;                    for (int outputArrPos = 0; outputArrPos &lt; expectedOutputArr.length; outputArrPos++) {&#10;                        if (outputArr[outputArrPos] != expectedOutputArr[outputArrPos]) {&#10;                            allInputsMatch = false;&#10;                            break inputArrArrPosLoop;&#10;                        }&#10;                    }&#10;                }&#10;                if (allInputsMatch) {&#10;                    matchingRuleListArr[pos].add(ruleNr);&#10;                }&#10;            }&#10;            System.out.printf(&quot;%s: %s\n&quot;, opName, matchingRuleListArr[pos]);&#10;        }&#10;&#10;        if (showExtraResults) {&#10;            System.out.printf(&quot;---------------------------------------------------------%n&quot;);&#10;            for (int pos = 0; pos &lt; opOutputArr.size(); pos++) {&#10;                final OpOutput opOutput = opOutputArr.get(pos);&#10;&#10;                final String opName = opOutput.opName();&#10;                final int[][] expectedOutputArrArr = opOutput.expectedOutputArrArr();&#10;&#10;                System.out.printf(&quot;%s: %s\n&quot;, opName, matchingRuleListArr[pos]);&#10;                if (matchingRuleListArr[pos].size() &gt; 0) {&#10;                    printGridForOperation(opName, matchingRuleListArr[pos].getFirst(), inputArrArr, expectedOutputArrArr, sizeX, sizeY);&#10;                }&#10;            }&#10;        }&#10;        Integer universalRuleNr = null;&#10;        for (int pos = 0; pos &lt; matchingRuleListArr.length; pos++) {&#10;            final List&lt;Integer&gt; matchingRuleList = matchingRuleListArr[pos];&#10;&#10;        }&#10;        return universalRuleNr;&#10;    }&#10;&#10;    private static void printGridForOperation(String opName, int ruleNr, int[][] inputArrArr, int[][] expectedOutputArrArr, int sizeX, int sizeY) {&#10;        System.out.printf(&quot;Operation: %s, Regel: %d\n&quot;, opName, ruleNr);&#10;        for (int inputArrArrPos = 0; inputArrArrPos &lt; inputArrArr.length; inputArrArrPos++) {&#10;            final int[] inputArr = inputArrArr[inputArrArrPos];&#10;            final int[] expectedOutputArr = expectedOutputArrArr[inputArrArrPos];&#10;            final Grid grid = GridService.createGrid(sizeX, sizeY, ruleNr);&#10;            GridService.submitInput(grid, inputArr);&#10;            CellNetService.calcGrid(grid);&#10;            final int[] outputArr = GridService.retieveOutput(grid);&#10;            System.out.printf(&quot;Eingabe: %s, Erwartete Ausgabe: %s, TatsÃ¤chliche Ausgabe: %s\n&quot;, Arrays.toString(inputArr), Arrays.toString(expectedOutputArr), Arrays.toString(outputArr));&#10;            printGrid(grid);&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    private static void printGrid(Grid grid) {&#10;        for (int y = 0; y &lt; grid.sizeY; y++) {&#10;            for (int x = 0; x &lt; grid.sizeX; x++) {&#10;                System.out.print(grid.cellArr[y][x].value + &quot; &quot;);&#10;            }&#10;            System.out.println();&#10;        }&#10;        System.out.println();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>